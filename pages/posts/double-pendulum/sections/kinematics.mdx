import AnimatedTimeSeriesPlotSvg from "../demos/animated-time-series-plot-svg.js";
import SimulationTimeSeriesPlot from "../figures/plots/SimulationTimeSeriesPlot.js";

## forward kinematics

<!-- In general, the process of computing the position (or related derivatives) of a
point in the system is known as forward kinematics. Mathematically, this can be
written concisely as $\bold{x} = f(\bm{\theta})$, where $\bold{x}$ is a vector,
representing the state of the system in _cartesian_ coordinates and
$\bm{\theta}$ is a vector representing the state of the system in _generalized_
coordinates, and $f$ is a function that maps from the generalized
coordinates to the cartesian coordinates.

In the case of the double pendulum we have modeled above, this means computing
cartesian coordinates of the point masses $x_a$, $y_a$, $x_b$ and $y_b$ in terms
of the joint angles, $\theta_a$ and $\theta_b$. To derive the forward kinematic
function, $f$, we can rely entirely on geometry as it only depends on
$\bm{\theta}$.

While we could keep the vector notation mentioned by letting
$\bold{x} = \begin{bmatrix}x_a& y_a& x_b & y_b \end{bmatrix}^T$, it feels a
unecessary for our purposes. Also, there will be quite a bit of sinsoidial
functions, so we denote $\sin\theta_x$ and $\cos\theta_x$ as $s_x$ and $c_x$ for
convenience. -->

---

The cartesian positions of the point masses can be derived using geometry by
inspection. We denote $\sin\theta_x$ and $\cos\theta_x$ as $s_x$ and $c_x$.

$$
\begin{alignedat}{3}
x_a =& &s_al_a& \\
y_a =& -&c_al_a&  \\
x_b =& &s_al_a& + s_bl_b \\
\tag{1} y_b =& -&c_al_a& -c_bl_b
\end{alignedat}
$$

---

<!-- 
Here is a plot of these positions over time. The present is on the right, with time flow backwards to the left.
Qualitatively, the plots are quite smooth and follow a sort of braiding pattern. -->

Positions over time.

<SimulationTimeSeriesPlot
  xMin={t => t - 10000}
  xMax={t => t}
  yMin={_ => -60}
  yMax={_ => 60}
  transforms={[
    s => s.a.x,
    s => s.a.y,
    s => s.b.x,
    s => s.b.y
  ]}
/>

---

Taking the derivative of the positions with respect to time, we get the velocities.

$$
\begin{alignedat}{3}
\dot{x_a} &= &c_al_a\dot{\theta_a}& \\
\dot{y_a} &= &s_al_a\dot{\theta_a}& \\
\dot{x_b} &= &c_al_a\dot{\theta_a}& + c_bl_b\dot{\theta_b} \\
\dot{y_b} &= &s_al_a\dot{\theta_a}& + s_bl_b\dot{\theta_b}
\end{alignedat}
$$

<SimulationTimeSeriesPlot
  xMin={t => t - 10000}
  xMax={t => t}
  yMin={_ => -300}
  yMax={_ => 300}
  transforms={[
    s => s.a.dx,
    s => s.a.dy,
    s => s.b.dx,
    s => s.b.dy
  ]}
/>

---

Taking the derivatives once more with respet to time, we get the accelerations:

$$
\begin{alignedat}{3}
\ddot{x_a} &= c_al_a\ddot{\theta_a} - s_al_a\dot{\theta_a}^2 \\
\ddot{y_a} &= s_al_a\ddot{\theta_a} + c_al_a\dot{\theta_a}^2 \\
\ddot{x_b} &= c_al_a\ddot{\theta_a} + c_bl_b\ddot{\theta_b} - s_al_a\dot{\theta_a}^2 - s_bl_b\dot{\theta_b}^2 \\
\ddot{y_b} &= s_al_a\ddot{\theta_a} + s_bl_b\ddot{\theta_b} + c_al_a\dot{\theta_a}^2 + c_bl_b\dot{\theta_b}^2
\end{alignedat}
$$

<SimulationTimeSeriesPlot
  xMin={t => t - 10000}
  xMax={t => t}
  yMin={_ => -6000}
  yMax={_ => 6000}
  transforms={[
    s => s.a.ddx,
    s => s.a.ddy,
    s => s.b.ddx,
    s => s.b.ddy
  ]}
/>

<!-- 
<SimulationTimeSeriesPlot
  xMin={t => t - 1000}
  xMax={t => t}
  yMin={_ => -6000}
  yMax={_ => 6000}
  transforms={[
    s => s.a.ddx,
    s => s.a.ddy,
    s => s.b.ddx,
    s => s.b.ddy
  ]}
/>
 -->
