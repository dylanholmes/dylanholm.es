import AnimatedTimeSeriesPlotSvg from "../demos/animated-time-series-plot-svg.js";
import AnimatedTimeSeriesPlotCanvas from "../demos/animated-time-series-plot-canvas-global.js";

## forward kinematics

In general, the process of computing the position (or related derivatives) of a
point in the system is known as forward kinematics. Mathematically, this can be
written concisely as $\bold{x} = f(\bm{\theta})$, where $\bold{x}$ is a vector,
representing the state of the system in _cartesian_ coordinates and
$\bm{\theta}$ is a vector representing the state of the system in _generalized_
coordinates, and $f$ is a function that maps from the generalized
coordinates to the cartesian coordinates.

In the case of the double pendulum we have modeled above, this means computing
cartesian coordinates of the point masses $x_a$, $y_a$, $x_b$ and $y_b$ in terms
of the joint angles, $\theta_a$ and $\theta_b$. To derive the forward kinematic
function, $f$, we can rely entirely on geometry as it only depends on
$\bm{\theta}$. 

While we could keep the vector notation mentioned by letting  
$\bold{x} = \begin{bmatrix}x_a& y_a& x_b & y_b \end{bmatrix}^T$, it feels a 
unecessary for our purposes. Also, there will be quite a bit of sinsoidial
functions, so we denote $\sin\theta_x$ and $\cos\theta_x$ as $s_x$ and $c_x$ for
convenience.

The positions of the point masses can be derived using geometry by inspection. Plotting the 

$$
\begin{alignedat}{3}
x_a =& &s_al_a& \\
y_a =& -&c_al_a&  \\
x_b =& &s_al_a& + s_bl_b \\
\tag{1} y_b =& -&c_al_a& -c_bl_b 
\end{alignedat}
$$

Here is a plot of these positions over time. The present is on the right, with time flow backwards to the left. Qualitatively, the plots are quite smooth and follow a sort of braiding pattern. 
<!-- 
<AnimatedTimeSeriesPlot
  toPoints={
    ({sim:{currentState:{a,b}}}) => [a.x, a.y, b.x, b.y].map(v => 0.5*v)
  }
/> -->
<!-- 
<AnimatedTimeSeriesPlotSvg
  toSequences={({sim:{lowResStates}}) => {
    let foo = toValues => {
      return {
        capacity: lowResStates.capacity,
        values: lowResStates.toArray().map(toValues)
      }
    };
    return [
      foo(s => 0.5* s.a.x),
      foo(s => 0.5* s.a.y),
      foo(s => 0.5* s.b.x),
      foo(s => 0.5* s.b.y)
    ];
  }}
/> -->

The velocities can then be derived by taking the derivative of the positions
with respect to time:

$$
\begin{alignedat}{3}
\dot{x_a} &= &c_al_a\dot{\theta_a}& \\
\dot{y_a} &= &s_al_a\dot{\theta_a}& \\
\dot{x_b} &= &c_al_a\dot{\theta_a}& + c_bl_b\dot{\theta_b} \\
\dot{y_b} &= &s_al_a\dot{\theta_a}& + s_bl_b\dot{\theta_b}
\end{alignedat}
$$

Similarly, we can plot the velocities over time. The plot looks somewhat similar to the position time series, although it is a littl..
<!-- 
<AnimatedTimeSeriesPlot
  toPoints={
    ({sim:{currentState:{a,b}}}) => [a.dx, a.dy, b.dx, b.dy].map(v => 0.1*v)
  }
/> -->
<!-- 
<AnimatedTimeSeriesPlotSvg
  toSequences={({sim:{lowResStates}}) => {
    let foo = toValues => {
      return {
        capacity: lowResStates.capacity,
        values: lowResStates.toArray().map(toValues)
      }
    };
    return [
      foo(s => 0.1* s.a.dx),
      foo(s => 0.1* s.a.dy),
      foo(s => 0.1* s.b.dx),
      foo(s => 0.1* s.b.dy)
    ];
  }}
/> -->

Taking the derivatives once more with respet to time, we get the accelerations:

$$
\begin{alignedat}{3}
\ddot{x_a} &= c_al_a\ddot{\theta_a} - s_al_a\dot{\theta_a}^2 \\
\ddot{y_a} &= s_al_a\ddot{\theta_a} + c_al_a\dot{\theta_a}^2 \\
\ddot{x_b} &= c_al_a\ddot{\theta_a} + c_bl_b\ddot{\theta_b} - s_al_a\dot{\theta_a}^2 - s_bl_b\dot{\theta_b}^2 \\
\ddot{y_b} &= s_al_a\ddot{\theta_a} + s_bl_b\ddot{\theta_b} + c_al_a\dot{\theta_a}^2 + c_bl_b\dot{\theta_b}^2
\end{alignedat}
$$
<!-- 
<AnimatedTimeSeriesPlotSvg
  toSequences={({sim:{lowResStates}}) => {
    let foo = toValues => {
      return {
        capacity: lowResStates.capacity,
        values: lowResStates.toArray().map(toValues)
      }
    };
    return [
      foo(s => 0.01* s.a.ddx),
      foo(s => 0.01* s.a.ddy),
      foo(s => 0.01* s.b.ddx),
      foo(s => 0.01* s.b.ddy)
    ];
  }}
/> -->
<!-- 
<AnimatedTimeSeriesPlotCanvas
  toSequences={({sim:{lowResStates}}) => {
    let foo = toValues => {
      return {
        capacity: lowResStates.length,
        values: lowResStates.map(toValues)
      }
    };
    return [
      foo(s => 0.0001* s.a.ddx),
      foo(s => 0.0001* s.a.ddy),
      foo(s => 0.0001* s.b.ddx),
      foo(s => 0.0001* s.b.ddy)
    ];
  }}
/> -->

<AnimatedTimeSeriesPlotCanvas
  toSequences={({lowResStates}) => {
    //console.log(lowResStates);
    let foo = toValues => {
      return {
        capacity: lowResStates.length,
        values: lowResStates.map(toValues)
      }
    };
    return [
      foo(x => 0.01 * x)
      // foo(s => 0.0001* s.a.ddy),
      // foo(s => 0.0001* s.b.ddx),
      // foo(s => 0.0001* s.b.ddy)
    ];
  }}
/>

Zooming in (we can se it is still smooth?):
<!-- 
<AnimatedTimeSeriesPlotSvg
  toSequences={({sim:{medResStates}}) => {
    let foo = toValues => {
      return {
        capacity: medResStates.capacity,
        values: medResStates.toArray().map(toValues)
      }
    };
    return [
      foo(s => 0.01* s.a.ddx),
      foo(s => 0.01* s.a.ddy),
      foo(s => 0.01* s.b.ddx),
      foo(s => 0.01* s.b.ddy)
    ];
  }}
/> -->