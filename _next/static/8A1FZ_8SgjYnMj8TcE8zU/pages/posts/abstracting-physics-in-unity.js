(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{"JvA+":function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/abstracting-physics-in-unity",function(){return n("qdMl")}])},qdMl:function(e,t,n){"use strict";n.r(t),n.d(t,"meta",(function(){return h})),n.d(t,"default",(function(){return m}));var i,o=n("wx14"),a=n("Ff2n"),s=n("q1tI"),c=n.n(s),r=n("7ljp"),l=n("nOHt"),p=n("/B9C"),h=(c.a.createElement,{published:!1,publishedAt:"2020-02-22",title:"Abstracting Physics in Unity",summary:"\xdf",image:""}),u=(i="Unity",function(e){return console.warn("Component "+i+" was not imported, exported, or provided by MDXProvider as global scope"),Object(r.b)("div",e)}),b={meta:h},y=Object(l.withRouter)((function(e){var t=e.children,n=e.router;return Object(r.b)(p.a,{path:n.pathname,meta:h},t)}));function m(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)(y,Object(o.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",null,"Problem"),Object(r.b)("p",null,"Unity currently comes with two possible physic engine integrations; the default\nPhysX integration and new preview-only Havok integration. Its great to see more\nchoices coming out of the box, but the integrations are not seamless. The PhysX\nintegration requires a Monobehaviour-centric workflow, while Havok requires\nswitching over to the new ECS workflow. This couples the choice of physics\nintegration to the project workflow early on as switching later may require you\nto essentially re-write your whole project."),Object(r.b)("p",null,"The standard software engineering practice to decouple components in situations\nlike this is to use a combination of abstraction and inversion of control. In\nthis post we'll look at how we can apply these concepts to abstracting the physics\nin Unity in a way that will allow us to easily swap out our physics integration,\nwhether that be between PhysX, Havok, or some custom physics integration. We'll\nalso consider the design choices that go into selecting an appropriate abstraction\n(nothing's free)."),Object(r.b)("h2",null,"Designing the Abstraction Layer"),Object(r.b)("p",null,"Designing an abstraction layer boils down to deciding on a common interface that\ncan support all the implemenations you plan on supporting. In our case, the\nimplementations (the physics integrations) are already existing and can be\nexpected to differ in a non trivial way, for example they may have differing\nsettings, or some features may only be available in one or the other. There are\ntwo common approaches to desiging an interface between existing implenations, the\nchoice of which depends on the project goals."),Object(r.b)("p",null,"The first choice is to limit the interface to only functionality that is supported\nby all of the implementations. This functionality is the intersection of the\nfunctionality supported by all implemenations."),Object(r.b)("p",null,"The second choice is to expand the interface to all functionality that is supported\nby any of the implemenations. This functionality is the union of the\nfunctionality supported by all implemenations."),Object(r.b)("p",null,"While these choices sound pretty black and white, they are not."),Object(r.b)(u,{buildJsonPath:"/static/2020_02_22_unity_setup/BoxDrop.json",unityLoaderJsPath:"/static/2020_02_22_unity_setup/UnityLoader.js",mdxType:"Unity"}),Object(r.b)("h2",null),Object(r.b)("p",null,"Let's get started with unity."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-bash"}),"$ ./some-shell-script.sh\n$ b.\n$ sss.sh\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-cs"}),'public class Main {\n  public static void main(String[] args) {\n    System.out.println("Ahoy!");\n  }\n}\n')),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),'public class Main {\n  public static void main(String[] args) {\n    System.out.println("Ahoy!");\n  }\n}\n')))}m.isMDXComponent=!0}},[["JvA+",0,2,1,3,4]]]);